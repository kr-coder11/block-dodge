<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Dodger</title>
    <!-- Load Tailwind CSS for easy responsive utility classes and aesthetics -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game container and canvas */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark theme background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        #game-container {
            position: relative;
            background-color: #2e0d37; /* Game background */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 4px solid #7a2b96;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            display: block;
            border-radius: 8px;
            background-color: #1a1a2e;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            z-index: 10;
        }

        .message-box {
            padding: 30px;
            background: linear-gradient(145deg, #4d1c58, #3a1642);
            border-radius: 12px;
            text-align: center;
            color: #ffffff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            max-width: 90%;
        }

        .message-box button {
            transition: background-color 0.3s, transform 0.1s;
        }

        .message-box button:hover {
            background-color: #9c36b5;
            transform: scale(1.05);
        }

        .message-box button:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>

    <div id="game-container" class="p-4">
        <div class="text-white text-lg mb-2 flex justify-between w-full max-w-lg">
            <div id="score-display">Score: 0</div>
            <div id="speed-display">Speed: 1.0x</div>
        </div>
        <canvas id="gameCanvas" width="500" height="600" class="shadow-lg"></canvas>

        <!-- UI Overlay for Start/Game Over -->
        <div id="ui-overlay">
            <div class="message-box">
                <h2 id="overlay-title" class="text-3xl font-bold mb-3">Block Dodger</h2>
                <p id="overlay-message" class="text-md mb-6">Use the **Left** and **Right** arrow keys to move. Dodge the falling blocks!</p>
                <button id="start-button" class="px-6 py-3 bg-[#7a2b96] rounded-lg font-semibold shadow-md">
                    Start Game
                </button>
            </div>
        </div>
    </div>

    <script>
        // Set up the Tailwind configuration to use the Inter font
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }

        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiOverlay = document.getElementById('ui-overlay');
        const startButton = document.getElementById('start-button');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayMessage = document.getElementById('overlay-message');
        const scoreDisplay = document.getElementById('score-display');
        const speedDisplay = document.getElementById('speed-display');

        // Game State Variables
        let isGameOver = true;
        let score = 0;
        let currentSpeedMultiplier = 1.0;
        let lastSpeedIncreaseTime = 0;
        // CHANGED: Speed now increases every 2 seconds (2000ms)
        const SPEED_INCREASE_INTERVAL = 2000; 
        const BASE_BLOCK_VELOCITY = 5; // Initial speed of main blocks

        // Player Variables
        const player = {
            width: 50,
            height: 10,
            x: canvas.width / 2 - 25,
            y: canvas.height - 30,
            color: '#ffc107', // Bright yellow/gold
            speed: 7, // Player horizontal movement speed
        };

        // Block Variables
        let blocks = [];
        const BLOCK_WIDTH = 40;
        const BLOCK_HEIGHT = 40;
        const BLOCK_COLOR = '#ff4d4d'; // Red/danger color
        let blockSpawnRate = 90; // Decreased from 120 for denser start
        let frameCount = 0;

        // Projectile Variables
        let projectiles = [];
        const PROJECTILE_WIDTH = 8;
        const PROJECTILE_HEIGHT = 8;
        const PROJECTILE_COLOR = '#4db8ff'; // Blue/Cyan color
        const PROJECTILE_VELOCITY_SCALE = 1.5; // Projectile speed relative to block speed
        const PROJECTILE_SHOOT_RATE = 40; // 120 frames at 60fps = approx 2 seconds

        // Input Handling
        const keysPressed = {};
        window.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
            // Prevent scrolling with arrow keys
            if (['ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });
        window.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        // --- Core Functions ---

        /**
         * Resets the game state and starts the main loop.
         */
        function startGame() {
            isGameOver = false;
            score = 0;
            blocks = [];
            projectiles = []; // Reset projectiles
            currentSpeedMultiplier = 1.0;
            lastSpeedIncreaseTime = performance.now();
            frameCount = 0;
            player.x = canvas.width / 2 - player.width / 2; // Center the player
            uiOverlay.style.display = 'none';

            // Reset score and speed display
            updateScoreDisplay();
            updateSpeedDisplay();

            gameLoop();
        }

        /**
         * Ends the game and shows the game over screen.
         */
        function endGame() {
            isGameOver = true;
            overlayTitle.textContent = 'Game Over!';
            overlayMessage.innerHTML = `You dodged obstacles for **${score}** seconds! <br> Ready for another round?`;
            startButton.textContent = 'Play Again';
            uiOverlay.style.display = 'flex';
        }

        /**
         * Draws the player character on the canvas.
         */
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.shadowColor = '#ffc107';
            ctx.shadowBlur = 15;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.shadowBlur = 0; // Reset shadow
        }

        /**
         * Updates player position based on key input.
         */
        function updatePlayer() {
            if (keysPressed['ArrowLeft'] && player.x > 0) {
                player.x -= player.speed;
            }
            if (keysPressed['ArrowRight'] && player.x < canvas.width - player.width) {
                player.x += player.speed;
            }
        }

        /**
         * Creates a new falling block object.
         */
        function spawnBlock() {
            const randomX = Math.random() * (canvas.width - BLOCK_WIDTH);
            const block = {
                x: randomX,
                y: -BLOCK_HEIGHT, // Start above the screen
                width: BLOCK_WIDTH,
                height: BLOCK_HEIGHT,
                color: BLOCK_COLOR,
                velocity: BASE_BLOCK_VELOCITY * currentSpeedMultiplier,
                lastShotFrame: frameCount // Track the last frame it shot
            };
            blocks.push(block);
        }

        /**
         * Creates a new projectile from a block.
         */
        function spawnProjectile(block) {
            const proj = {
                // Positioned below the center of the block
                x: block.x + block.width / 2 - PROJECTILE_WIDTH / 2,
                y: block.y + block.height, 
                width: PROJECTILE_WIDTH,
                height: PROJECTILE_HEIGHT,
                color: PROJECTILE_COLOR,
                // Projectiles move faster than their parent block
                velocity: block.velocity * PROJECTILE_VELOCITY_SCALE
            };
            projectiles.push(proj);
        }

        /**
         * Updates and draws all falling blocks, and triggers shooting.
         */
        function updateBlocks() {
            const currentBlockVelocity = BASE_BLOCK_VELOCITY * currentSpeedMultiplier;

            for (let i = blocks.length - 1; i >= 0; i--) {
                const block = blocks[i];

                // Update block velocity
                block.velocity = currentBlockVelocity;

                // Move block down
                block.y += block.velocity;

                // Draw block
                ctx.fillStyle = block.color;
                ctx.shadowColor = block.color;
                ctx.shadowBlur = 10;
                ctx.fillRect(block.x, block.y, block.width, block.height);
                ctx.shadowBlur = 0;

                // Shooting Logic (shoots approximately every 2 seconds)
                if (frameCount - block.lastShotFrame >= PROJECTILE_SHOOT_RATE) {
                    // Only shoot if the block is visible on screen
                    if (block.y > 0 && block.y < canvas.height - 50) {
                        spawnProjectile(block);
                    }
                    block.lastShotFrame = frameCount; // Reset shot frame
                }

                // Remove block if it goes off screen (bottom)
                if (block.y > canvas.height) {
                    blocks.splice(i, 1);
                }

                // Check for collision with player
                if (checkCollision(player, block)) {
                    endGame();
                    return;
                }
            }
        }

        /**
         * Updates, draws, and checks collision for all projectiles.
         */
        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];

                // Move projectile down
                proj.y += proj.velocity;

                // Draw projectile
                ctx.fillStyle = proj.color;
                ctx.shadowColor = proj.color;
                ctx.shadowBlur = 8;
                ctx.fillRect(proj.x, proj.y, proj.width, proj.height);
                ctx.shadowBlur = 0;

                // Remove projectile if it goes off screen (bottom)
                if (proj.y > canvas.height) {
                    projectiles.splice(i, 1);
                    continue; // Skip collision check for removed projectile
                }

                // Check for collision with player
                if (checkCollision(player, proj)) {
                    endGame();
                    return; // End game immediately on hit
                }
            }
        }

        /**
         * Checks for AABB collision between two rectangles.
         */
        function checkCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }

        /**
         * Manages score, speed increase, and block spawning.
         */
        function gameLogic(currentTime) {
            // 1. Score Update (since 60 frames = approx 1 second)
            if (frameCount % 60 === 0) {
                score++;
                updateScoreDisplay();
            }

            // 2. Speed Increase Logic
            if (currentTime - lastSpeedIncreaseTime >= SPEED_INCREASE_INTERVAL) {
                currentSpeedMultiplier += 0.2; // Increase speed by 20%
                lastSpeedIncreaseTime = currentTime;
                updateSpeedDisplay();
            }

            // 3. Block Spawning
            // Calculate an aggressive multiplier for density increase (squared value)
            const densityMultiplier = currentSpeedMultiplier * currentSpeedMultiplier;

            // Density scaling: The spawn rate is reduced by the aggressive multiplier.
            // Math.max(20, ...) ensures a minimum gap between blocks.
            const calculatedSpawnRate = Math.max(20, Math.floor(blockSpawnRate / densityMultiplier));

            if (frameCount % calculatedSpawnRate === 0) {
                spawnBlock();
            }

            frameCount++;
        }

        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score}`;
        }

        function updateSpeedDisplay() {
            speedDisplay.textContent = `Speed: ${currentSpeedMultiplier.toFixed(1)}x`;
        }


        // --- Main Game Loop ---
        function gameLoop(currentTime) {
            if (isGameOver) return;

            // 1. Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Game Logic (Time, Score, Spawning)
            gameLogic(currentTime);

            // 3. Update Positions
            updatePlayer();
            updateBlocks();
            updateProjectiles(); // Check projectile movement and collisions

            // 4. Draw Elements
            drawPlayer();

            // 5. Loop
            requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---

        startButton.addEventListener('click', startGame);

        // Show the initial start screen on load
        window.onload = () => {
            // Ensure the canvas container width is responsive but max 500px
            const container = document.getElementById('game-container');
            const size = Math.min(500, window.innerWidth - 40);
            canvas.width = size;
            canvas.height = size * 1.2; // Maintain an aspect ratio
            player.x = canvas.width / 2 - player.width / 2;
            player.y = canvas.height - 30;

            container.style.maxWidth = `${size + 32}px`; // padding + canvas
            uiOverlay.style.display = 'flex';
        };

        // Make sure the canvas resizes somewhat gracefully on viewport change
        window.addEventListener('resize', () => {
            if (isGameOver) {
                const size = Math.min(500, window.innerWidth - 40);
                canvas.width = size;
                canvas.height = size * 1.2;
                player.x = canvas.width / 2 - player.width / 2;
                player.y = canvas.height - 30;
                document.getElementById('game-container').style.maxWidth = `${size + 32}px`;
            }
        });

    </script>
</body>
</html>

